#!/usr/bin/env python3
# cocoon-launch - COCOON node launcher (worker/proxy/client, QEMU or local)
import os
import re
import sys
import argparse
import shutil
import tempfile
import subprocess
import configparser
import signal
from dataclasses import dataclass, field
from typing import Dict
from pathlib import Path


def run(cmd, **kwargs):
    """subprocess.run wrapper that prints command"""
    print(f'+ {" ".join(str(x) for x in cmd)}')
    return subprocess.run(cmd, **kwargs)


def popen(cmd, **kwargs):
    """subprocess.Popen wrapper that prints command"""
    print(f'+ {" ".join(str(x) for x in cmd)}')
    return subprocess.Popen(cmd, **kwargs)


@dataclass
class ModelBuild:
    name: str
    commit: str
    verity_hash: str
    tar_path: str


def build_model_if_needed(model_spec: str) -> ModelBuild:
    script_dir = Path(__file__).parent
    build_model_script = script_dir / 'build-model'

    print(f'Building model: {model_spec}')
    result = run([str(build_model_script), model_spec],
                 stdout=subprocess.PIPE, text=True, check=True)

    # Parse output: "model@commit:hash /path/to/tar"
    output = result.stdout.strip()
    print(f'Result: {output}')
    if ' ' not in output:
        sys.exit(f'ERROR: Invalid build-model output: {output}')

    full_spec, tar_path = output.split(' ', 1)

    # Parse full_spec: model@commit:hash
    if '@' not in full_spec or ':' not in full_spec:
        sys.exit(f'ERROR: Invalid model spec from build-model: {full_spec}')

    if not Path(tar_path).is_file():
        sys.exit(f'ERROR: Model tar not found: {tar_path}')

    model_name, rest = full_spec.split('@', 1)
    commit, verity_hash = rest.split(':', 1)

    return ModelBuild(name=model_name, commit=commit, verity_hash=verity_hash, tar_path=tar_path)


@dataclass
class Config:
    """Unified configuration for any node type"""
    node_type: str
    spec_dir: str
    owner_address: str

    # Common
    root_contract_address: str | None = None
    model: str | None = None
    external_ip: str | None = None
    external_worker_port: int | None = None
    external_client_port: int | None = None
    node_wallet_key: str | None = None  # for worker and client

    # Runtime control
    test: bool = False
    fake_ton: bool = False  # Disable real TON, use fake TON for testing
    local_mode: bool = False  # True for --local-all and local client execution
    instance: int = 0

    # Worker-specific
    worker_coefficient: str = '1000'
    hf_token: str | None = None

    # TON configs
    ton_config_base: str | None = None
    ton_config: str | None = None

    # Paths
    image_dir: str | None = None
    build_dir: str | None = None
    local_run_dir: str | None = None
    model_tar_path: str | None = None
    prepared_spec_dir: str | None = None

    # Model metadata (parsed from model spec)
    model_commit: str | None = None
    model_verity_hash: str | None = None

    # QEMU/hardware
    gpu: str | None = None
    persistent: str | None = None
    ssh_port: int | None = None
    vsock_cid: int | None = None
    tcp_ports: list[int] = field(default_factory=list)
    no_tdx: bool = False

    # Extra
    extra_vars: Dict[str, str] = field(default_factory=dict)
    extra_qemu_args: list[str] = field(default_factory=list)
    prepare_only: bool = False
    print_only: bool = False
    skip_build: bool = False
    just_build: bool = False

    def __str__(self) -> str:
        """Pretty print config"""
        lines = [f'\n=== Config ({self.node_type}) ===']

        # Group fields by category (matching dataclass order)
        sections = [
            ('Common', ['root_contract_address', 'model', 'external_ip', 'external_worker_port',
                        'external_client_port', 'node_wallet_key']),
            ('Runtime', ['test', 'fake_ton', 'local_mode', 'instance']),
            ('Worker', ['worker_coefficient', 'hf_token']),
            ('TON configs', ['ton_config_base', 'ton_config']),
            ('Paths', ['image_dir', 'build_dir', 'local_run_dir', 'model_tar_path', 'prepared_spec_dir']),
            ('Model', ['model_commit', 'model_verity_hash']),
            ('QEMU/hardware', ['gpu', 'persistent', 'ssh_port', 'vsock_cid', 'tcp_ports', 'no_tdx']),
            ('Extra', ['prepare_only', 'print_only', 'skip_build', 'just_build']),
        ]

        for section, fields in sections:
            values = {f: getattr(self, f) for f in fields if getattr(self, f, None) is not None}
            if not values:
                continue
            lines.append(f'\n{section}:')
            for key, val in values.items():
                # Redact sensitive values
                if key in ['node_wallet_key', 'hf_token']:
                    val = '<redacted>'
                lines.append(f'  {key}: {val}')

        if self.extra_vars:
            lines.append(f'\nExtra vars:')
            for k, v in self.extra_vars.items():
                lines.append(f'  {k}: {v}')

        lines.append('=' * 40)
        return '\n'.join(lines)

    def get_runtime_vars(self) -> Dict[str, str]:
        """Get all runtime vars for spec rendering"""
        vars = {**self.extra_vars}  # extra_vars takes precedence

        if self.model:
            # Only build model for worker running in QEMU (not local mode)
            if self.node_type == 'worker' and not self.local_mode:
                # Build model and get metadata
                build = build_model_if_needed(self.model)

                # Store in config for later use
                self.model_tar_path = build.tar_path
                self.model_commit = build.commit
                self.model_verity_hash = build.verity_hash

                # Set runtime vars
                vars.setdefault('MODEL_NAME', build.name)
                vars.setdefault('MODEL_COMMIT', build.commit)
                vars.setdefault('MODEL_VERITY_HASH', build.verity_hash)
            else:
                # For non-worker or local mode, just set MODEL_NAME
                vars.setdefault('MODEL_NAME', self.model)
        offset = self.instance * 10
        if self.node_type == 'client':
            vars.setdefault('CLIENT_HTTP_PORT', 10000 + offset)
            vars.setdefault('CLIENT_RPC_PORT', 10001 + offset)

        if self.owner_address:
            vars.setdefault('OWNER_ADDRESS', self.owner_address)
        vars.setdefault('ROOT_CONTRACT_ADDRESS', self.root_contract_address)
        if self.external_ip:
            vars.setdefault('EXTERNAL_IP', self.external_ip)
        if self.external_worker_port:
            vars.setdefault('EXTERNAL_WORKER_PORT', self.external_worker_port + offset)
        if self.external_client_port:
            vars.setdefault('EXTERNAL_CLIENT_PORT', self.external_client_port + offset)
        if self.worker_coefficient:
            vars.setdefault('WORKER_COEFFICIENT', self.worker_coefficient)
        if self.hf_token:
            vars.setdefault('HF_TOKEN', self.hf_token)
        if self.node_wallet_key:
            vars.setdefault('NODE_WALLET_KEY', self.node_wallet_key)

        return vars


def load_config_from_file(cli_args) -> Config:
    ini = configparser.ConfigParser()
    if cli_args.config_file:
        ini.read(cli_args.config_file)

    def get(key, default=None):
        # First check CLI args, then config file, then defaults
        cli_val = getattr(cli_args, key, None)
        if cli_val is not None:
            return cli_val
        return ini.get('node', key, fallback=default)

    def getint(key, default):
        val = get(key)
        return int(val) if val is not None else default

    def getbool(key, default=False):
        """Get boolean from config or CLI args"""
        cli_val = getattr(cli_args, key, None)
        if cli_val is not None:
            return cli_val
        val = ini.get('node', key, fallback=None)
        if val is None:
            return default
        # Handle various boolean representations
        print(key, val)
        return val.lower() in ('true', 'yes', '1', 'on')

    script_dir = Path(__file__).parent.parent
    build_dir = get('build_dir') or os.environ.get('BUILD_DIR') or str(script_dir / 'cmake-build-default-tdx')
    prepared_spec_dir = str(Path(tempfile.mkdtemp(prefix='cocoon-spec-')) / 'spec')

    if cli_args.local_all:
        return Config(node_type='local_all', spec_dir='', owner_address='', build_dir=build_dir,
                      prepared_spec_dir=prepared_spec_dir, local_run_dir='/tmp/run/', local_mode=True)

    node_type = get('type', '').lower()

    instance = getint('instance', 0)

    # Auto-spec
    spec = cli_args.spec or str(script_dir / 'spec' / f'spec-{node_type}')
    fake_ton = getbool('fake_ton', False)
    test = getbool('test', False)

    # Build config (ordered to match Config dataclass)
    cfg = Config(
        node_type=node_type,
        spec_dir=spec,
        owner_address=get('owner_address') or '',
        # Common
        root_contract_address=get('root_contract_address', 'EQBcXvP9DUA4k5tqUapcilt4kZnBzF0Ts7OW0Yp5FI0aN7g0'),
        model=get('model', 'Qwen/Qwen3-0.6B' if fake_ton or node_type == 'worker' else None),
        external_ip=get('external_ip', '10.0.2.2') if fake_ton else None,
        external_worker_port=getint('external_worker_port', 11001) if fake_ton else None,
        external_client_port=getint('external_client_port', 11002) if fake_ton else None,
        node_wallet_key=get('node_wallet_key',
                            'gaEatwGNgLGOeFI/TRGfPdJG/K4G8picYHQkDHpLQ9w=' if fake_ton else None),
        # Runtime control
        test=test,
        fake_ton=fake_ton,
        instance=instance,
        # Worker-specific
        worker_coefficient=get('worker_coefficient', '1000'),
        hf_token=get('hf_token') or os.environ.get('HF_TOKEN'),
        # TON configs
        ton_config_base=get('ton_config_base',
                            str(script_dir / 'spec/mainnet-base-ton-config.json')) if not fake_ton else None,
        ton_config=get('ton_config',
                       str(script_dir / 'spec/mainnet-full-ton-config.json')) if not fake_ton else None,
        # Paths
        image_dir=get('image-dir', str(script_dir / 'images' / ('test' if test else 'prod'))),
        build_dir=get('build_dir', build_dir),
        prepared_spec_dir=prepared_spec_dir,
        # QEMU/hardware
        gpu=get('gpu'),
        persistent=get('persistent', f'persistent-{node_type}-{instance}.img'),
        ssh_port=getint('ssh_port', None),
        vsock_cid=getint('vsock_cid', None),
        no_tdx=cli_args.no_tdx,
        # Extra
        prepare_only=cli_args.prepare_only,
        print_only=cli_args.print_only,
        skip_build=cli_args.skip_build,
        just_build=cli_args.just_build,
    )

    # Type-specific defaults
    if node_type == 'worker':
        cfg.tcp_ports = [getint('http_port', 12000)]
        cfg.ssh_port = getint('ssh_port', 12005)
        cfg.vsock_cid = getint('vsock_cid', 6)  # Worker: 6, 16, 26...
    elif node_type == 'proxy':
        cfg.tcp_ports = [getint('http_port', 11000),
                         getint('worker_rpc_port', 11001),
                         getint('client_rpc_port', 11002)]
        cfg.ssh_port = getint('ssh_port', 11005)
        cfg.vsock_cid = getint('vsock_cid', 7)  # Proxy: 7, 17, 27...
    elif node_type == 'client':
        cfg.local_run_dir = tempfile.mkdtemp(prefix='cocoon-client-')
        cfg.extra_vars.update({
            'IS_DEBUG': int(cfg.test),
            'TON_CONFIG_FILE': f'{cfg.local_run_dir}/global.config.json',
        })

    # Validate
    if not node_type:
        sys.exit('ERROR: type not set in config')
    if node_type not in ('worker', 'proxy', 'client'):
        sys.exit(f'ERROR: Invalid type: {node_type}')
    if not cfg.owner_address:
        sys.exit('ERROR: owner_address required')
    if node_type == 'worker' and not cfg.model:
        sys.exit('ERROR: model required for worker')

    # Parse --set args
    for entry in getattr(cli_args, 'set', []):
        if '=' not in entry:
            sys.exit(f'ERROR: invalid --set: {entry}')
        k, v = entry.split('=', 1)
        cfg.extra_vars[k] = v

    # Extra QEMU args
    cfg.extra_qemu_args = cli_args.extra if hasattr(cli_args, 'extra') else []
    if cfg.extra_qemu_args and cfg.extra_qemu_args[0] == '--':
        cfg.extra_qemu_args = cfg.extra_qemu_args[1:]

    return cfg


def adjust_runner_services(spec_dir: str, fake_ton: bool) -> None:
    """Add --disable-ton fake-ton-config.json flag to runner services in fake-ton mode"""
    if not fake_ton:
        return

    for name in os.listdir(spec_dir):
        if not name.endswith('.service'):
            continue
        path = os.path.join(spec_dir, name)
        with open(path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        # Append -C flag to ExecStart lines with -runner (if not already present)
        for i, ln in enumerate(lines):
            if ln.startswith('ExecStart=') and '-runner' in ln and '/run/spec/fake-ton-config.json' not in ln:
                lines[i] = ln.rstrip('\n') + ' --disable-ton /run/spec/fake-ton-config.json\n'

        with open(path, 'w', encoding='utf-8') as f:
            f.writelines(lines)


def print_spec_info(cfg: Config):
    """Print detailed information about prepared spec"""
    spec_path = Path(cfg.prepared_spec_dir)

    print('\n' + '=' * 70)
    print(f'SPEC: {spec_path}')
    print('=' * 70)

    # List all files with permissions and sizes
    print('\nFiles:')
    for item in sorted(spec_path.rglob('*')):
        if item.is_file():
            stat = item.stat()
            mode = oct(stat.st_mode)[-3:]
            size = stat.st_size
            print(f'  {mode} {size:6d}  {item.relative_to(spec_path)}')

    # Print key files with content
    print('\n' + '=' * 70)
    for pattern, label in [
        ('runtime/runtime.vars', 'RUNTIME VARS'),
        ('*.json', 'CONFIG'),
        ('*.service', 'SERVICE'),
        ('init', 'INIT SCRIPT'),
    ]:
        for file in sorted(spec_path.glob(pattern)):
            if 'global.config' in file.name:
                continue  # Skip TON config

            print(f'\n[{label}] {file.name}')
            print('-' * 70)
            content = file.read_text()

            # Redact sensitive keys in runtime.vars
            if file.name == 'runtime.vars':
                for key in ['APP_KEY', 'NODE_WALLET_KEY', 'HF_TOKEN']:
                    content = re.sub(rf'^{key}=.*$', f'{key}=<redacted>', content, flags=re.MULTILINE)

            print(content.rstrip())
            print('-' * 70)

    print('=' * 70 + '\n')


def prepare_spec(cfg: Config):
    print(f'Preparing {cfg.node_type}: {cfg.spec_dir}->{cfg.prepared_spec_dir}')

    if not Path(cfg.spec_dir).is_dir():
        sys.exit(f'ERROR: spec dir not found: {cfg.spec_dir}')

    dest = cfg.prepared_spec_dir
    shutil.copytree(cfg.spec_dir, dest)

    # Apply TON configs
    if cfg.ton_config_base and Path(cfg.ton_config_base).exists():
        shutil.copy(cfg.ton_config_base, f'{dest}/global.config.json')
    elif not cfg.fake_ton:
        sys.exit(f'ERROR: ton_config_base not found: {cfg.ton_config_base}')

    if cfg.ton_config and Path(cfg.ton_config).exists():
        os.makedirs(f'{dest}/runtime', exist_ok=True)
        shutil.copy(cfg.ton_config, f'{dest}/runtime/global.config.json')
    elif not cfg.fake_ton:
        sys.exit(f'ERROR: ton_config not found: {cfg.ton_config}')

    # Apply fake-ton mode
    if cfg.fake_ton:
        script_dir = Path(__file__).parent.parent
        fake_ton_dir = script_dir / 'spec/fake-ton'

        shutil.copy(fake_ton_dir / 'fake-ton-config.json', f'{dest}/fake-ton-config.json')

        # Append fake-ton runtime.vars
        os.makedirs(f'{dest}/runtime', exist_ok=True)
        with open(f'{dest}/runtime/runtime.vars', 'a') as out:
            out.write((fake_ton_dir / 'runtime.vars').read_text())

        # Inject render line and filter TON config from init
        init_path = Path(dest) / 'init'
        if init_path.exists():
            def process_init():
                injected = False
                for line in init_path.read_text().splitlines():
                    # Skip TON config rendering
                    if 'cocoon-render-ton-config' in line:
                        continue
                    # Inject fake-ton config rendering before systemctl
                    if not injected and 'systemctl' in line:
                        yield 'cocoon-render-config fake-ton-config.json'
                        injected = True
                    yield line

            init_path.write_text('\n'.join(process_init()) + '\n')

    # Write runtime vars
    runtime_vars = cfg.get_runtime_vars()
    if runtime_vars:
        var_file = Path(dest) / 'runtime/runtime.vars'
        var_file.parent.mkdir(exist_ok=True)

        # Merge with existing (upsert)
        existing_lines = []
        existing_keys = set()
        if var_file.exists():
            for line in var_file.read_text().splitlines():
                if '=' in line and line.strip():
                    k = line.split('=', 1)[0]
                    if k not in runtime_vars:
                        existing_lines.append(line)
                        existing_keys.add(k)

        # Add new/updated vars
        for k, v in runtime_vars.items():
            existing_lines.append(f'{k}={v}')

        var_file.write_text('\n'.join(existing_lines) + '\n')

    # Adjust service files for fake-ton mode
    adjust_runner_services(dest, cfg.fake_ton)


def render_configs_local(cfg: Config):
    """Render configs for local execution"""
    os.environ['COCOON_SUBST'] = f'{cfg.build_dir}/tee/cocoon-subst'
    os.environ['COCOON_RUN_DIR'] = cfg.local_run_dir
    cocoon_init = Path(__file__).parent.parent / 'reprodebian/cocoon-init'

    # Clean and create output directory
    run(['rm', '-rf', cfg.local_run_dir], check=False)
    run(['mkdir', '-p', cfg.local_run_dir], check=True)

    # Render JSON configs (except global.config.json)
    for config_file in Path(cfg.prepared_spec_dir).glob('*.json'):
        if config_file.name != 'global.config.json':
            run([str(cocoon_init / 'cocoon-render-config-local'), str(config_file)], check=True)

    # Render TON config (handles global.config.json)
    if not cfg.fake_ton:
        run([str(cocoon_init / 'cocoon-render-ton-config-local'), cfg.prepared_spec_dir], check=True)


def run_client_local(cfg: Config):
    """Run client locally (connects to actual proxies)"""
    render_configs_local(cfg)

    import threading

    def stream_output(proc, prefix, color_code):
        """Read process output line by line and prefix each line"""
        for line in proc.stdout:
            print(f"\033[{color_code}m[{prefix}]\033[0m {line}", end='', flush=True)

    # Start router (SOCKS5 only, no reverse proxy) with colored output
    router = f'{cfg.build_dir}/tee/router'
    router_proc = popen([router, '-S', '8116@tdx', '--serialize-info'],
                       stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
    router_thread = threading.Thread(target=stream_output, args=(router_proc, 'ROUTER', '36'), daemon=True)
    router_thread.start()

    # Run client with colored output
    client_cmd = [f'{cfg.build_dir}/client-runner', '--config', f'{cfg.local_run_dir}/client-config.json', '-v3']
    if cfg.fake_ton:
        client_cmd += ['--disable-ton', f'{cfg.local_run_dir}/fake-ton-config.json']

    client_proc = popen(client_cmd,
                       stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
    client_thread = threading.Thread(target=stream_output, args=(client_proc, 'CLIENT', '33'), daemon=True)
    client_thread.start()

    try:
        # Wait for client to finish
        client_proc.wait()
    finally:
        router_proc.terminate()
        router_proc.wait()


def run_qemu(cfg: Config):
    """Run worker/proxy in QEMU/TDX"""
    # Verify GPU
    if cfg.gpu:
        setup_gpu_script = Path(__file__).parent / 'setup-gpu-vfio'
        result = run([str(setup_gpu_script), cfg.gpu], check=False)
        if result.returncode != 0:
            sys.exit(f'ERROR: GPU not ready. Run: sudo {setup_gpu_script} --setup {cfg.gpu}')

    # Verify model .tar files exist
    model_tar_file = None
    model_verity_file = None

    if cfg.model_tar_path:
        model_tar_file = Path(cfg.model_tar_path)
        model_verity_file = Path(cfg.model_tar_path + ".verity")

        if not model_tar_file.exists():
            sys.exit(f'ERROR: Model .tar file not found: {model_tar_file}')

        if not model_verity_file.exists():
            sys.exit(f'ERROR: Model .tar.verity file not found: {model_verity_file}')

    # Create persistent disk
    if cfg.persistent and not Path(cfg.persistent).exists():
        run(['truncate', '--size=100g', cfg.persistent], check=True)

    # Build QEMU command
    offset = cfg.instance * 10

    # vsock CID with instance*10 offset (consistent with ports)
    vsock_cid = cfg.vsock_cid + (cfg.instance * 10)

    netdev = 'user,id=user.0'
    if cfg.ssh_port:
        netdev += f',hostfwd=tcp::{cfg.ssh_port + offset}-:22'
    for guest_port in cfg.tcp_ports:
        netdev += f',hostfwd=tcp::{guest_port + offset}-:{guest_port}'

    # Read cmdline
    cmdline_file = Path(cfg.image_dir) / 'image.cmdline'
    cmdline = cmdline_file.read_text().strip()
    if cfg.test:
        cmdline += ' cocoon_debug'
    if cfg.fake_ton:
        cmdline += ' cocoon_fake_ton'
    cmdline += ' cocoon_gpu' if cfg.gpu else ' modprobe.blacklist=nvidia'

    # Check OVMF
    ovmf = Path(cfg.image_dir) / 'OVMF.fd'
    if not ovmf.exists():
        sys.exit(f'ERROR: OVMF.fd not found: {ovmf}')

    machine = 'q35,kernel-irqchip=split,memory-backend=mem0'
    if not cfg.no_tdx:
        machine += ',confidential-guest-support=tdx'

    tdx_obj = [] if cfg.no_tdx else ['-object',
                                     '{"qom-type":"tdx-guest","id":"tdx","quote-generation-socket":{"type":"vsock","cid":"2","port":"4050"}}']
    gpu_cmd = ['-device', f'vfio-pci,host={cfg.gpu},bus=pci.0,iommufd=iommufd0'] if cfg.gpu else []
    tar_cmd = ['-drive', f'readonly=on,file={model_tar_file},id=drivecache,if=none,index=3,werror=report',
               '-device', 'virtio-blk-pci,drive=drivecache,serial=model-tar',
               '-drive', f'readonly=on,file={model_verity_file},id=drivecacheverity,if=none,index=4,werror=report',
               '-device', 'virtio-blk-pci,drive=drivecacheverity,serial=model-tar-verity'] if cfg.model_tar_path else []

    qemu = ['qemu-system-x86_64',
            '-machine', machine,
            '-bios', str(ovmf),
            '-accel', 'kvm', '-cpu', 'host', '-smp', '32',
            '-vga', 'none',
            *tdx_obj,
            '-object', 'memory-backend-ram,id=mem0,size=100G',
            '-device', f'vhost-vsock-pci,guest-cid={vsock_cid}',
            '-object', 'iommufd,id=iommufd0',
            '-device', 'pcie-root-port,id=pci.0,bus=pcie.0',
            '-drive',
            f'cache=writeback,file={cfg.image_dir}/image.img,readonly=on,id=drive1,if=none,index=1,werror=report',
            '-device', 'virtio-blk-pci,bootindex=1,drive=drive1,serial=root',
            '-drive', f'cache=writeback,file={cfg.persistent},format=raw,id=drive2,if=none,index=2,werror=report',
            '-device', 'virtio-blk-pci,bootindex=2,drive=drive2,serial=persistent',
            *tar_cmd,
            '-chardev', 'stdio,id=char0',
            '-device', 'virtio-serial-pci,id=virtio-serial0',
            '-device', 'virtconsole,chardev=char0',
            '-kernel', f'{cfg.image_dir}/image.vmlinuz',
            '-initrd', f'{cfg.image_dir}/image.initrd',
            '-append', cmdline,
            '-virtfs', f'local,path={cfg.prepared_spec_dir},mount_tag=spec,security_model=mapped,readonly=on',
            '-net', 'nic,netdev=user.0,model=virtio',
            '-netdev', netdev,
            '-nographic',
            '-serial', 'null',
            '-monitor', 'null',
            *gpu_cmd,
            *cfg.extra_qemu_args]

    print('QEMU:', ' '.join(qemu))
    if cfg.print_only:
        return

    os.execvp(qemu[0], qemu)


def ensure_build(build_dir: Path, targets: list[str]):
    """Ensure build directory exists and targets are built"""
    script_dir = Path(__file__).parent.parent

    # Initialize CMake if needed
    if not (build_dir / 'CMakeCache.txt').exists():
        print(f'Initializing CMake in {build_dir}...')
        build_dir.mkdir(parents=True, exist_ok=True)
        run(['cmake',
             '-GNinja',
             '-DCMAKE_BUILD_TYPE=RelWithDebInfo',
             '-DBUILD_SHARED_LIBS=OFF',
             '-DTON_USE_JEMALLOC=ON',
             '-DTON_USE_ABSEIL=OFF',
             '-DTON_ONLY_TONLIB=ON',
             '-DTON_USE_ROCKSDB=ON',
             '-S', str(script_dir),
             '-B', str(build_dir)], check=True)

    # Build targets
    print(f'Building {", ".join(targets)}...')
    run(['cmake', '--build', str(build_dir), '-j', str(os.cpu_count() or 4),
         '--target'] + targets, check=True)


def run_local_all(cfg):
    print('=== Running COCOON locally (all components) ===')
    print('Fake TON, Test, No VM. Config is mostly ignored')

    maybe_build(cfg)

    script_dir = Path(__file__).parent.parent
    prepared_spec_dir = Path(cfg.prepared_spec_dir)
    os.environ['COCOON_SUBST'] = str(Path(cfg.build_dir) / 'tee/cocoon-subst')

    # Common test config
    base_vars = {
        'owner_address': 'UQAuz15H1ZHrZ_psVrAra7HealMIVeFq0wguqlmFno1f3B-m',
        'root_contract_address': 'EQBT4hy4vMEZ9uxSCuhw_gBKh9_AwmHXLe7Wo0O4Vh-4kRjJ',
        'model': 'Qwen/Qwen3-8B',
    }

    # For local-all, everything runs on 127.0.0.1
    specs = {}
    for node_type, hash_val, app_key in [
        ('proxy', 'ProxyProxyProxyProxyProxyProxyProxyProxyPro=', 'ml+7xELuOQtfp9q9mSWtHiSWx5aSBV6p3xCfwPmHOwY='),
        ('worker', 'WorkerWorkerWorkerWorkerWorkerWorkerWorkerU=', 'jYYD/HjU0K2D/xpistoFM4BruJhY3koI1xuO00xd7PI='),
        ('client', 'ClientClientClientClientClientClientClientC=', 'gaEatwGNgLGOeFI/TRGfPdJG/K4G8picYHQkDHpLQ9w='),
    ]:
        cfg = Config(
            node_type=node_type,
            spec_dir=str(script_dir / 'spec' / f'spec-{node_type}'),
            external_ip='127.0.0.1',  # Local-all uses localhost
            external_worker_port=11001,
            external_client_port=11002,
            node_wallet_key=app_key,  # just for tests make it same as APP_KEY
            fake_ton=True,
            local_mode=True,  # Don't build models for local execution
            test=True,
            build_dir=cfg.build_dir,
            prepared_spec_dir=str(prepared_spec_dir) + f"-{node_type}",
            **base_vars
        )
        cfg.extra_vars.update({
            'TDX_IMAGE_HASH': hash_val,
            'TON_CONFIG_FILE': '/tmp/run/global.config.json',
            'APP_KEY': app_key,
            'DISK_PATH': '/tmp',
            'MODEL_COMMIT': 'abc123def456',
            'MODEL_VERITY_HASH': '0000000000000000000000000000000000000000000000000000000000000000',
            'IS_DEBUG': int(cfg.test),
        })
        if node_type == 'worker':
            cfg.worker_coefficient = '0'

        prepare_spec(cfg)
        specs[node_type] = cfg.prepared_spec_dir

    # Render all
    print('\nRendering configs...')

    # Clean rendered output files first
    run(['rm', '-rf', '/tmp/run'], check=False)
    run(['mkdir', '-p', '/tmp/run'], check=True)

    cocoon_init = script_dir / 'reprodebian/cocoon-init'
    for spec_dir in specs.values():
        # Render JSON configs (except global.config.json)
        for cfg_file in Path(spec_dir).glob('*.json'):
            if cfg_file.name != 'global.config.json':
                run([str(cocoon_init / 'cocoon-render-config-local'), str(cfg_file)], check=True)

    # Start all
    print('\nStarting components...')
    run(['rm', '-rf', '/tmp/proxy-db/'], check=False)

    import threading

    def stream_output(proc, prefix, color_code):
        """Read process output line by line and prefix each line"""
        for line in proc.stdout:
            print(f"\033[{color_code}m[{prefix}]\033[0m {line}", end='', flush=True)

    procs = []
    threads = []

    # Proxy (blue)
    proxy_proc = popen(
        [f'{cfg.build_dir}/proxy-runner', '--config', '/tmp/run/proxy-config.json', '-v3', '--disable-ton',
         '/tmp/run/fake-ton-config.json'],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
    procs.append(proxy_proc)
    t = threading.Thread(target=stream_output, args=(proxy_proc, 'PROXY ', '34'), daemon=True)
    t.start()
    threads.append(t)

    # Worker (green)
    worker_proc = popen(
        [f'{cfg.build_dir}/worker-runner', '--config', '/tmp/run/worker-config.json', '-v3', '--disable-ton',
         '/tmp/run/fake-ton-config.json'],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
    procs.append(worker_proc)
    t = threading.Thread(target=stream_output, args=(worker_proc, 'WORKER', '32'), daemon=True)
    t.start()
    threads.append(t)

    # Client (yellow)
    client_proc = popen(
        [f'{cfg.build_dir}/client-runner', '--config', '/tmp/run/client-config.json', '-v3', '--disable-ton',
         '/tmp/run/fake-ton-config.json'],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
    procs.append(client_proc)
    t = threading.Thread(target=stream_output, args=(client_proc, 'CLIENT', '33'), daemon=True)
    t.start()
    threads.append(t)

    # Proxy-cli (cyan)
    proxycli_proc = popen([f'{cfg.build_dir}/tee/router', '-S', '8116@any',
                           '-R', '11001:127.0.0.1:11101@any',
                           '-R', '11002:127.0.0.1:11102@any',
                           '--serialize-info'],
                          stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
    procs.append(proxycli_proc)
    t = threading.Thread(target=stream_output, args=(proxycli_proc, 'ROUTER', '36'), daemon=True)
    t.start()
    threads.append(t)

    print('\nAll components started. Press Ctrl+C to stop.')

    try:
        signal.pause()
    except KeyboardInterrupt:
        print('\nStopping...')
        for p in procs:
            p.terminate()
        for p in procs:
            p.wait(timeout=5)


def parse_args():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(allow_abbrev=False)

    # Config file or explicit args
    parser.add_argument('config_file', nargs='?', help='Config file (INI format)')
    parser.add_argument('--type', choices=['worker', 'proxy', 'client'], help='Node type')
    parser.add_argument('--spec', help='Path to spec directory')

    # Node config
    parser.add_argument('--model', help='MODEL_NAME')
    parser.add_argument('--owner-address', help='OWNER_ADDRESS')
    parser.add_argument('--root-contract-address', help='ROOT_CONTRACT_ADDRESS')
    parser.add_argument('--worker-coefficient', help='WORKER_COEFFICIENT')
    parser.add_argument('--hf-token', help='HF_TOKEN')
    parser.add_argument('--external-ip', help='EXTERNAL_IP')
    parser.add_argument('--external-worker-port', help='EXTERNAL_WORKER_PORT')
    parser.add_argument('--external-client-port', help='EXTERNAL_CLIENT_PORT')
    parser.add_argument('--wallet-private-key', dest='node_wallet_key', help='NODE_WALLET_KEY')
    parser.add_argument('--node-wallet_key', dest='node_wallet_key', help='NODE_WALLET_KEY')

    # TON configs
    parser.add_argument('--ton-config-base', dest='ton_config_base',
                        help='Immutable TON config base (blockchain constants)')
    parser.add_argument('--ton-config', dest='ton_config', help='User-provided TON config (liteservers)')

    # Modes
    parser.add_argument('--test', action='store_true', default=None, help='Test mode (debug shell, SSH)')
    parser.add_argument('--fake-ton', '--pseudo', action='store_true', default=None, dest='fake_ton',
                        help='Fake-TON mode (disable real TON network)')
    parser.add_argument('--local-all', action='store_true', help='Run all components locally')
    parser.add_argument('--prepare-only', action='store_true', help='Prepare spec to /tmp/spec/')
    parser.add_argument('--print-only', action='store_true', help='Print command and exit')
    parser.add_argument('--skip-build', action='store_true', help='Skip auto-build (use existing binaries)')
    parser.add_argument('--just-build', action='store_true', help='Just build all binaries')

    # QEMU args
    parser.add_argument('-d', '--debug', action='store_true')
    parser.add_argument('--instance', type=int)
    parser.add_argument('--persistent', help='Persistent disk image')
    parser.add_argument('--gpu', help='GPU PCI address')
    parser.add_argument('--ssh-port', type=int)
    parser.add_argument('--vsock-cid', type=int)
    parser.add_argument('--tcp', action='append', type=int, default=[])
    parser.add_argument('--no-tdx', action='store_true')
    parser.add_argument('--image-dir', help='Image directory')
    parser.add_argument('--build-dir', help='Build directory (defaults to BUILD_DIR env or cmake-build-default-tdx)')

    # Extra
    parser.add_argument('--set', action='append', default=[], help='Extra runtime vars (K=V)')
    parser.add_argument('extra', nargs=argparse.REMAINDER)

    return parser.parse_args()


def maybe_build(cfg: Config):
    """Build if in source repo and not --skip-build"""
    script_dir = Path(__file__).parent.parent
    if (script_dir / 'tee').is_dir() and not cfg.skip_build:
        ensure_build(Path(cfg.build_dir), ['cocoon-all'])
    else:
        print("skip building from source")


def main():
    cfg = load_config_from_file(parse_args())

    if cfg.just_build:
        maybe_build(cfg);
        return;

    # Special mode: run all locally, just for tests
    if cfg.local_mode:
        run_local_all(cfg)
        return

    # Print config
    print(cfg)

    prepare_spec(cfg)
    print_spec_info(cfg)

    if cfg.prepare_only:
        return

    if cfg.node_type == 'client':
        maybe_build(cfg)  # build client first
        run_client_local(cfg)
    else:
        # Worker/Proxy run in QEMU - no local build needed
        run_qemu(cfg)


if __name__ == '__main__':
    main()
